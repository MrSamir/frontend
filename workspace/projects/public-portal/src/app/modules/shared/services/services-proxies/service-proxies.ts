//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AppCoreConfigurationsServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAppCoreConfigurations(): Observable<AppCore> {
        let url_ = this.baseUrl + "/api/AppCoreConfigurationsService/GetAppCoreConfigurations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppCoreConfigurations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppCoreConfigurations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppCore>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppCore>;
        }));
    }

    protected processGetAppCoreConfigurations(response: HttpResponseBase): Observable<AppCore> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppCore.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EntitySampleApplicationServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEntity(body: CreateSampleEntityDto | undefined): Observable<ApiResponseOfEntitySampleDto> {
        let url_ = this.baseUrl + "/api/EntitySampleApplicationService/CreateEntity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponseOfEntitySampleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponseOfEntitySampleDto>;
        }));
    }

    protected processCreateEntity(response: HttpResponseBase): Observable<ApiResponseOfEntitySampleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfEntitySampleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEntitySample(id: number | undefined): Observable<ApiResponseOfEntitySampleDto> {
        let url_ = this.baseUrl + "/api/EntitySampleApplicationService/GetEntitySample?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntitySample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntitySample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponseOfEntitySampleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponseOfEntitySampleDto>;
        }));
    }

    protected processGetEntitySample(response: HttpResponseBase): Observable<ApiResponseOfEntitySampleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfEntitySampleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEntity(body: UpdateSampleEntity | undefined): Observable<ApiResponseOfEntitySampleDto> {
        let url_ = this.baseUrl + "/api/EntitySampleApplicationService/UpdateEntity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponseOfEntitySampleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponseOfEntitySampleDto>;
        }));
    }

    protected processUpdateEntity(response: HttpResponseBase): Observable<ApiResponseOfEntitySampleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfEntitySampleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LookupApplicationServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllLookups(body: InputLookUpDto | undefined): Observable<ApiResponseOfPagedResultDtoOfLookupDto> {
        let url_ = this.baseUrl + "/api/LookupApplicationService/GetAllLookups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponseOfPagedResultDtoOfLookupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponseOfPagedResultDtoOfLookupDto>;
        }));
    }

    protected processGetAllLookups(response: HttpResponseBase): Observable<ApiResponseOfPagedResultDtoOfLookupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfPagedResultDtoOfLookupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getById(body: InputLookUpDto | undefined): Observable<ApiResponseOfLookupDto> {
        let url_ = this.baseUrl + "/api/LookupApplicationService/GetById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponseOfLookupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponseOfLookupDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ApiResponseOfLookupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfLookupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SendNotificationApplicationServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param requestNumber (optional) 
     * @param templateGroupId (optional) 
     * @param roleName (optional) 
     * @return Success
     */
    sendNotificationForRole(requestNumber: string | undefined, templateGroupId: number | undefined, roleName: string | undefined): Observable<ApiResponseOfSentNotificationMessagesDto> {
        let url_ = this.baseUrl + "/api/SendNotificationApplicationService/SendNotificationForRole?";
        if (requestNumber === null)
            throw new Error("The parameter 'requestNumber' cannot be null.");
        else if (requestNumber !== undefined)
            url_ += "requestNumber=" + encodeURIComponent("" + requestNumber) + "&";
        if (templateGroupId === null)
            throw new Error("The parameter 'templateGroupId' cannot be null.");
        else if (templateGroupId !== undefined)
            url_ += "templateGroupId=" + encodeURIComponent("" + templateGroupId) + "&";
        if (roleName === null)
            throw new Error("The parameter 'roleName' cannot be null.");
        else if (roleName !== undefined)
            url_ += "roleName=" + encodeURIComponent("" + roleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendNotificationForRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendNotificationForRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponseOfSentNotificationMessagesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponseOfSentNotificationMessagesDto>;
        }));
    }

    protected processSendNotificationForRole(response: HttpResponseBase): Observable<ApiResponseOfSentNotificationMessagesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfSentNotificationMessagesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param requestNumber (optional) 
     * @param templateGroupId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendNotificationUsers(requestNumber: string | undefined, templateGroupId: number | undefined, body: string[] | undefined): Observable<ApiResponseOfSentNotificationMessagesDto> {
        let url_ = this.baseUrl + "/api/SendNotificationApplicationService/SendNotificationUsers?";
        if (requestNumber === null)
            throw new Error("The parameter 'requestNumber' cannot be null.");
        else if (requestNumber !== undefined)
            url_ += "requestNumber=" + encodeURIComponent("" + requestNumber) + "&";
        if (templateGroupId === null)
            throw new Error("The parameter 'templateGroupId' cannot be null.");
        else if (templateGroupId !== undefined)
            url_ += "templateGroupId=" + encodeURIComponent("" + templateGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendNotificationUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendNotificationUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponseOfSentNotificationMessagesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponseOfSentNotificationMessagesDto>;
        }));
    }

    protected processSendNotificationUsers(response: HttpResponseBase): Observable<ApiResponseOfSentNotificationMessagesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfSentNotificationMessagesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WeatherForecastServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ApiResponseOfEntitySampleDto implements IApiResponseOfEntitySampleDto {
    isSuccess!: boolean;
    dto!: EntitySampleDto;
    message!: string | undefined;
    validationResultMessages!: ValidationResultMessage[] | undefined;

    constructor(data?: IApiResponseOfEntitySampleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.dto = _data["dto"] ? EntitySampleDto.fromJS(_data["dto"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["validationResultMessages"])) {
                this.validationResultMessages = [] as any;
                for (let item of _data["validationResultMessages"])
                    this.validationResultMessages!.push(ValidationResultMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResponseOfEntitySampleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfEntitySampleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["dto"] = this.dto ? this.dto.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.validationResultMessages)) {
            data["validationResultMessages"] = [];
            for (let item of this.validationResultMessages)
                data["validationResultMessages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResponseOfEntitySampleDto {
    isSuccess: boolean;
    dto: EntitySampleDto;
    message: string | undefined;
    validationResultMessages: ValidationResultMessage[] | undefined;
}

export class ApiResponseOfLookupDto implements IApiResponseOfLookupDto {
    isSuccess!: boolean;
    dto!: LookupDto;
    message!: string | undefined;
    validationResultMessages!: ValidationResultMessage[] | undefined;

    constructor(data?: IApiResponseOfLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.dto = _data["dto"] ? LookupDto.fromJS(_data["dto"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["validationResultMessages"])) {
                this.validationResultMessages = [] as any;
                for (let item of _data["validationResultMessages"])
                    this.validationResultMessages!.push(ValidationResultMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResponseOfLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["dto"] = this.dto ? this.dto.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.validationResultMessages)) {
            data["validationResultMessages"] = [];
            for (let item of this.validationResultMessages)
                data["validationResultMessages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResponseOfLookupDto {
    isSuccess: boolean;
    dto: LookupDto;
    message: string | undefined;
    validationResultMessages: ValidationResultMessage[] | undefined;
}

export class ApiResponseOfPagedResultDtoOfLookupDto implements IApiResponseOfPagedResultDtoOfLookupDto {
    isSuccess!: boolean;
    dto!: PagedResultDtoOfLookupDto;
    message!: string | undefined;
    validationResultMessages!: ValidationResultMessage[] | undefined;

    constructor(data?: IApiResponseOfPagedResultDtoOfLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.dto = _data["dto"] ? PagedResultDtoOfLookupDto.fromJS(_data["dto"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["validationResultMessages"])) {
                this.validationResultMessages = [] as any;
                for (let item of _data["validationResultMessages"])
                    this.validationResultMessages!.push(ValidationResultMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResponseOfPagedResultDtoOfLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfPagedResultDtoOfLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["dto"] = this.dto ? this.dto.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.validationResultMessages)) {
            data["validationResultMessages"] = [];
            for (let item of this.validationResultMessages)
                data["validationResultMessages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResponseOfPagedResultDtoOfLookupDto {
    isSuccess: boolean;
    dto: PagedResultDtoOfLookupDto;
    message: string | undefined;
    validationResultMessages: ValidationResultMessage[] | undefined;
}

export class ApiResponseOfSentNotificationMessagesDto implements IApiResponseOfSentNotificationMessagesDto {
    isSuccess!: boolean;
    dto!: SentNotificationMessagesDto;
    message!: string | undefined;
    validationResultMessages!: ValidationResultMessage[] | undefined;

    constructor(data?: IApiResponseOfSentNotificationMessagesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.dto = _data["dto"] ? SentNotificationMessagesDto.fromJS(_data["dto"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["validationResultMessages"])) {
                this.validationResultMessages = [] as any;
                for (let item of _data["validationResultMessages"])
                    this.validationResultMessages!.push(ValidationResultMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResponseOfSentNotificationMessagesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfSentNotificationMessagesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["dto"] = this.dto ? this.dto.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.validationResultMessages)) {
            data["validationResultMessages"] = [];
            for (let item of this.validationResultMessages)
                data["validationResultMessages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResponseOfSentNotificationMessagesDto {
    isSuccess: boolean;
    dto: SentNotificationMessagesDto;
    message: string | undefined;
    validationResultMessages: ValidationResultMessage[] | undefined;
}

export class AppCore implements IAppCore {
    localization!: Localization;
    settings!: Setting;

    constructor(data?: IAppCore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localization = _data["localization"] ? Localization.fromJS(_data["localization"]) : <any>undefined;
            this.settings = _data["settings"] ? Setting.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AppCore {
        data = typeof data === 'object' ? data : {};
        let result = new AppCore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAppCore {
    localization: Localization;
    settings: Setting;
}

export class CreateSampleEntityDto implements ICreateSampleEntityDto {
    name!: string | undefined;

    constructor(data?: ICreateSampleEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSampleEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSampleEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateSampleEntityDto {
    name: string | undefined;
}

export class EntitySampleDto implements IEntitySampleDto {
    name!: string | undefined;
    id!: number;

    constructor(data?: IEntitySampleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntitySampleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntitySampleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntitySampleDto {
    name: string | undefined;
    id: number;
}

export class InputLookUpDto implements IInputLookUpDto {
    lookUpName!: string | undefined;
    id!: number;
    lookupExtraDatas!: LookupExtraData[] | undefined;

    constructor(data?: IInputLookUpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lookUpName = _data["lookUpName"];
            this.id = _data["id"];
            if (Array.isArray(_data["lookupExtraDatas"])) {
                this.lookupExtraDatas = [] as any;
                for (let item of _data["lookupExtraDatas"])
                    this.lookupExtraDatas!.push(LookupExtraData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputLookUpDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputLookUpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lookUpName"] = this.lookUpName;
        data["id"] = this.id;
        if (Array.isArray(this.lookupExtraDatas)) {
            data["lookupExtraDatas"] = [];
            for (let item of this.lookupExtraDatas)
                data["lookupExtraDatas"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputLookUpDto {
    lookUpName: string | undefined;
    id: number;
    lookupExtraDatas: LookupExtraData[] | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    name!: string | undefined;
    languageData!: any | undefined;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.languageData = _data["languageData"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["languageData"] = this.languageData;
        return data;
    }
}

export interface ILanguageInfo {
    name: string | undefined;
    languageData: any | undefined;
}

export class Localization implements ILocalization {
    languagesInfo!: LanguageInfo[] | undefined;
    currentLanguage!: LanguageInfo;

    constructor(data?: ILocalization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["languagesInfo"])) {
                this.languagesInfo = [] as any;
                for (let item of _data["languagesInfo"])
                    this.languagesInfo!.push(LanguageInfo.fromJS(item));
            }
            this.currentLanguage = _data["currentLanguage"] ? LanguageInfo.fromJS(_data["currentLanguage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Localization {
        data = typeof data === 'object' ? data : {};
        let result = new Localization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.languagesInfo)) {
            data["languagesInfo"] = [];
            for (let item of this.languagesInfo)
                data["languagesInfo"].push(item.toJSON());
        }
        data["currentLanguage"] = this.currentLanguage ? this.currentLanguage.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILocalization {
    languagesInfo: LanguageInfo[] | undefined;
    currentLanguage: LanguageInfo;
}

export class LookupDto implements ILookupDto {
    localizedKey!: string | undefined;
    isEnabled!: boolean;
    name!: string | undefined;
    hintLoclizedKey!: string | undefined;
    hint!: string | undefined;
    lookupExtraDatas!: LookupExtraData[] | undefined;
    id!: number;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localizedKey = _data["localizedKey"];
            this.isEnabled = _data["isEnabled"];
            this.name = _data["name"];
            this.hintLoclizedKey = _data["hintLoclizedKey"];
            this.hint = _data["hint"];
            if (Array.isArray(_data["lookupExtraDatas"])) {
                this.lookupExtraDatas = [] as any;
                for (let item of _data["lookupExtraDatas"])
                    this.lookupExtraDatas!.push(LookupExtraData.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localizedKey"] = this.localizedKey;
        data["isEnabled"] = this.isEnabled;
        data["name"] = this.name;
        data["hintLoclizedKey"] = this.hintLoclizedKey;
        data["hint"] = this.hint;
        if (Array.isArray(this.lookupExtraDatas)) {
            data["lookupExtraDatas"] = [];
            for (let item of this.lookupExtraDatas)
                data["lookupExtraDatas"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ILookupDto {
    localizedKey: string | undefined;
    isEnabled: boolean;
    name: string | undefined;
    hintLoclizedKey: string | undefined;
    hint: string | undefined;
    lookupExtraDatas: LookupExtraData[] | undefined;
    id: number;
}

export class LookupExtraData implements ILookupExtraData {
    dataName!: string | undefined;
    dataValue!: string | undefined;

    constructor(data?: ILookupExtraData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataName = _data["dataName"];
            this.dataValue = _data["dataValue"];
        }
    }

    static fromJS(data: any): LookupExtraData {
        data = typeof data === 'object' ? data : {};
        let result = new LookupExtraData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataName"] = this.dataName;
        data["dataValue"] = this.dataValue;
        return data;
    }
}

export interface ILookupExtraData {
    dataName: string | undefined;
    dataValue: string | undefined;
}

export class NotificationMessageDto implements INotificationMessageDto {
    userName!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    provider!: string | undefined;
    referenceNumber!: string | undefined;
    errorType!: string | undefined;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    reTryCounter!: number | undefined;
    machineName!: string | undefined;
    isSent!: boolean | undefined;
    sentDatetime!: DateTime | undefined;
    parameters!: TemplateParameter[] | undefined;
    notificationTemplateId!: number;
    id!: string;

    constructor(data?: INotificationMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.provider = _data["provider"];
            this.referenceNumber = _data["referenceNumber"];
            this.errorType = _data["errorType"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.reTryCounter = _data["reTryCounter"];
            this.machineName = _data["machineName"];
            this.isSent = _data["isSent"];
            this.sentDatetime = _data["sentDatetime"] ? DateTime.fromISO(_data["sentDatetime"].toString()) : <any>undefined;
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(TemplateParameter.fromJS(item));
            }
            this.notificationTemplateId = _data["notificationTemplateId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["provider"] = this.provider;
        data["referenceNumber"] = this.referenceNumber;
        data["errorType"] = this.errorType;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["reTryCounter"] = this.reTryCounter;
        data["machineName"] = this.machineName;
        data["isSent"] = this.isSent;
        data["sentDatetime"] = this.sentDatetime ? this.sentDatetime.toString() : <any>undefined;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["notificationTemplateId"] = this.notificationTemplateId;
        data["id"] = this.id;
        return data;
    }
}

export interface INotificationMessageDto {
    userName: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    provider: string | undefined;
    referenceNumber: string | undefined;
    errorType: string | undefined;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    reTryCounter: number | undefined;
    machineName: string | undefined;
    isSent: boolean | undefined;
    sentDatetime: DateTime | undefined;
    parameters: TemplateParameter[] | undefined;
    notificationTemplateId: number;
    id: string;
}

export class PagedResultDtoOfLookupDto implements IPagedResultDtoOfLookupDto {
    totalCount!: number;
    items!: LookupDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLookupDto {
    totalCount: number;
    items: LookupDto[] | undefined;
}

export class SentNotificationMessagesDto implements ISentNotificationMessagesDto {
    notificationMessageDtos!: NotificationMessageDto[] | undefined;
    id!: string;

    constructor(data?: ISentNotificationMessagesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notificationMessageDtos"])) {
                this.notificationMessageDtos = [] as any;
                for (let item of _data["notificationMessageDtos"])
                    this.notificationMessageDtos!.push(NotificationMessageDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SentNotificationMessagesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SentNotificationMessagesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notificationMessageDtos)) {
            data["notificationMessageDtos"] = [];
            for (let item of this.notificationMessageDtos)
                data["notificationMessageDtos"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ISentNotificationMessagesDto {
    notificationMessageDtos: NotificationMessageDto[] | undefined;
    id: string;
}

export class Setting implements ISetting {
    appSettings!: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appSettings = _data["appSettings"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appSettings"] = this.appSettings;
        return data;
    }
}

export interface ISetting {
    appSettings: string | undefined;
}

export class TemplateParameter implements ITemplateParameter {
    key!: string | undefined;
    value!: any | undefined;

    constructor(data?: ITemplateParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TemplateParameter {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface ITemplateParameter {
    key: string | undefined;
    value: any | undefined;
}

export class UpdateSampleEntity implements IUpdateSampleEntity {
    id!: number;
    name!: string | undefined;

    constructor(data?: IUpdateSampleEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateSampleEntity {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSampleEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateSampleEntity {
    id: number;
    name: string | undefined;
}

export class ValidationResultDetails implements IValidationResultDetails {
    errorCode!: string | undefined;
    errorMessage!: string | undefined;

    constructor(data?: IValidationResultDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): ValidationResultDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResultDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IValidationResultDetails {
    errorCode: string | undefined;
    errorMessage: string | undefined;
}

export class ValidationResultMessage implements IValidationResultMessage {
    propertyName!: string | undefined;
    validationResultDetails!: ValidationResultDetails[] | undefined;

    constructor(data?: IValidationResultMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            if (Array.isArray(_data["validationResultDetails"])) {
                this.validationResultDetails = [] as any;
                for (let item of _data["validationResultDetails"])
                    this.validationResultDetails!.push(ValidationResultDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationResultMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResultMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        if (Array.isArray(this.validationResultDetails)) {
            data["validationResultDetails"] = [];
            for (let item of this.validationResultDetails)
                data["validationResultDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IValidationResultMessage {
    propertyName: string | undefined;
    validationResultDetails: ValidationResultDetails[] | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date!: DateTime;
    temperatureC!: number;
    readonly temperatureF!: number;
    summary!: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date: DateTime;
    temperatureC: number;
    temperatureF: number;
    summary: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}